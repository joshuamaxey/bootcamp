//! Measuring Performance

// The first step to improvind the efficiency of your code is to measure it.
// First, we measure your code's speed with TIMING BENCHMARKS.
// Then we learn to evaluate time and space efficiency of code at face-value through big-O analysis.

//! Choosing the Right Tool for the Job

// We can use ARRAYS or HASH TABLES to improve code efficiency.

// Everything is stored in computer memory using 1s and 0s (binary code).

// We can use binary logic to discern truth from 1s and 0s.

// We can use the LINKED LIST data structure to traverse data cross different memory locations. You will need to identify performance tradeoffs between the use of arrays vs linked lists.

// Links are also called POINTERS, MEMORY ADDRESSES, or MEMORY REFERENCES. They are related to trees and graphs, which you'll learn about later.

// There are variants of arrays, linked lists, and hash tables called STACKS, QUEUES, and SETS (respectively).

//! Problem Solving

//^ Polya

//& 1. Understand the problem.
// 2. Come up with a plan.
// 3. Execute the plan.
//& 4. Iterate and improve your solution.

// With respect to code efficiency, we will focus specifically on steps 1 and 4: understanding the problem, and improving our solutions to the problem.

//! Ask Questions

// The word science is operationally defined here as: //^ The pursuit of knowledge through systematic study.

// This means that computer science is the pursuit of knowledge thorugh systematic study of computers.

// Here, we will gain insight into how computers work. Learn to visualize your code.

// Because this material is more abstract than most of the material in the curriculum, it's important to ask good questions. Remember the three steps to asking good coding questions:

// 1. Make it specific
// 2. Make it clear and concise
// 3. Show that you put work into it

//! Have Fun

// Science is about experimentation, exploration, and discovery. Have fun.
